//traversal sort for graph have to do

//in dijkstra we use priority queue because it check first lower distance
//if dijkstra fails we use bellman ford it fails when weight is negative
#include<bits/stdc++.h>
using namespace std;
void dijkstra(vector<vector<pair<int,int>>>&adjList,int src,vector<int>&dis){
    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;
    pq.push({0,src});
    dis[src]=0;
    while(!pq.empty()){
        int node=pq.top().second;
        int d=pq.top().first;
        pq.pop();
        for(auto & ngbr:adjList[node]){
            int cost=ngbr.second;
            int ngbrNode=ngbr.first;
            if(cost+d<dis[ngbrNode]){
                dis[ngbrNode]=cost+d;
                pq.push({cost+d,ngbrNode});
            }
        }
    }
}
int main(){
    int v=2;
    vector<pair<int,pair<int,int>>>edges={{0,{1,8}},{0,{2,2}},{1,{2,4}}};
    vector<vector<pair<int,int>>>>adjlist
    vector<vector<pair<int,int>>>adjList(v+1);
    for(auto& x:edges){
        int u=x.first;
        int v=x.second.first;
        int w=x.second.second;
        adjList[u].push_back({v,w});
        adjList[v].push_back({u,w});
    }
    vector<int>dis(v+1,INT_MAX);
    int src=0;
    dijkstra(adjList,src,dis);
    return 0;
}
